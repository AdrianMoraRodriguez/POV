//Paso 1.
// Program.cs

using OpenTK.Windowing.Desktop;
using OpenTK.Mathematics;

public static class Program
{
    public static void Main()
    {
        var nativeWindowSetting=new NativeWindowSettings
        {
            Size=new Vector2i(800,600),
            Title="OpenTk Cube"
        };

        using(var window=new Window(GameWindowSettings.Default,nativeWindowSetting))
        {
            window.Run();
        }
    }
}

// Paso 2
// Usings de Window.cs

using LearnOpenTK.Common;
using OpenTK.Mathematics;
using OpenTK.Graphics.OpenGL4;
using OpenTK.Windowing.Common;
using OpenTK.Windowing.Desktop;

// Paso 3
// Clase Window vac\'ia
public class Window : GameWindow
{
}

// Paso4
// Un cubo definido mediante \'indices preparado para Face Culling Front is CCK
public float[] vertexData={

			// POS 	// COLOR
             -0.5f, -0.5f, -0.5f, 1.0f,  0.0f, 0.0f,1.0f, //0 
             -0.5f, -0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 1.0f, //1
             -0.5f, 0.5f, -0.5f, 0.0f, 0.0f, 1.0f,1.0f, //2
             -0.5f, 0.5f,  0.5f, 1.0f, 0.0f, 1.0f, 1.0f, //3
             0.5f, -0.5f, -0.5f, 1.0f,  0.0f, 0.0f,1.0f, //4
             0.5f, -0.5f, 0.5f, 0.0f, 1.0f, 0.0f, 1.0f, //5
             0.5f, 0.5f, -0.5f, 0.0f, 0.0f, 1.0f,1.0f, //6
             0.5f, 0.5f,  0.5f, 1.0f, 0.0f, 1.0f, 1.0f //7

    };

 public int[] indexData={
        6,4,0, //
        0,2,6, //
        7,1,5, //
        1,7,3, //
        3,2,0, //
        0,1,3, //
        4,6,7, // 
        7,5,4, //
        0,4,5, //
        5,1,0, //
        7,6,2, //
        2,3,7 //
    };

// Paso 5. Campos privados de la clase

	private int _vertexBuffer;
    private int _vertexArray;
    private int _indexBuffer;
	private Shader? _shader ;
    
	private Camera _camera;

    
    
    private Matrix4 _Model;

    private readonly Vector3 _Axis=new Vector3(1.0f,1.0f,1.0f);

    private readonly float _RotSpeed=1.0f;

    private float _RotAngle;

//  Paso 6. Copiar de LearnOpenTK los archivos Camera.cs y Shader.cs en la carpeta Common que 
// crearemos en nuestro proyecto

// Paso 7. Constructor de la clase Window. Inicializamos algunos de los campos de la clase,
// despu'es de llamar al constructor de la clase base GameWindow con la configuraci'on de la ventana

public Window(GameWindowSettings gameWindowSettings, NativeWindowSettings nativeWindowSettings)
    : base(gameWindowSettings,nativeWindowSettings)
    {
        _camera=new Camera(Vector3.UnitZ*3,Size.X / (float)Size.Y); 
        _Model= new Matrix4();
        _RotAngle=0.0f;
        

    }

// Paso 8. Crearemos la carpeta Shaders y crearemos ah'i los archivos shader.vert y shader.frag
// con los siguientes programas

// shader.vert
#version 330 core

layout(location=0) in vec3 aPosition;
layout(location=1) in vec4 aColor;

uniform mat4 view;
uniform mat4 model;
uniform mat4 projection;

out vec4 VertexColor;

void main(){
    vec4 position=vec4(aPosition,1.0f) * model * view * projection;
    VertexColor=aColor;
    gl_Position=position;
}

//shader.frag
#version 330 core 
in vec4 VertexColor;
out vec4 OutFragColor;
void main()
{
    OutFragColor=VertexColor;
}


// Paso 9. Creamos los m'etodos sobrecargados que usaremos, de momento vac'ios salvo por la llamada
// al correspndiente de la clase base

protected override void OnLoad()
    {
        base.OnLoad();
		
	}

 protected override void OnUpdateFrame(FrameEventArgs e)
    {
	
	}
	
	
protected override void OnRenderFrame(FrameEventArgs args)
    {
	
	}
	
 protected override void OnUnload()
    {
	
	
	}
	
// Paso 10. En OnLoad() abordamos primero la configuraci'on b'asica

 GL.ClearColor(0.2f,0.2f,0.2f,1.0f);
 GL.Enable(EnableCap.CullFace);
 GL.Enable(EnableCap.DepthTest);
 
 // Paso 11. En OnLoad abordamos la creaci'on de buffers y la copia de datos a la GPU
 
 // Buffers
_vertexBuffer=GL.GenBuffer();
GL.BindBuffer(BufferTarget.ArrayBuffer,_vertexBuffer);
GL.BufferData(BufferTarget.ArrayBuffer,vertexData.Length*sizeof(float),vertexData,BufferUsageHint.StaticDraw);

_indexBuffer=GL.GenBuffer();
GL.BindBuffer(BufferTarget.ElementArrayBuffer,_indexBuffer);
GL.BufferData(BufferTarget.ElementArrayBuffer,indexData.Length*sizeof(int),indexData,BufferUsageHint.StaticDraw);


// Paso 12. En OnLoad creamos el programa, resultante de la compilaci'on de los shaders, y lo habilitamos en el pipeline

 _shader=new Shader("Shaders/shader.vert","Shaders/shader.frag");
 _shader.Use();


// Paso13. Creamos un identificador para un  VAO y le hacemos un bind para
// que sea el VAO conectado en este momento.
 _vertexArray=GL.GenVertexArray();
 GL.BindVertexArray(_vertexArray);

// Paso 14. Creamos una definición de array de datos genéricos para un atributo 
// asociada al atributo aPosition y habilitada en el VAO actualmente conectado.
var posLocation = _shader.GetAttribLocation("aPosition");
GL.EnableVertexAttribArray(posLocation);
GL.VertexAttribPointer(posLocation,3,VertexAttribPointerType.Float,false,7*sizeof(float),0); 

// Paso 15. Creamos una definición de array de datos genéricos para un atributo 
// asociada al atributo aColor y habilitada en el VAO actualmente conectado.

var colorLocation = _shader.GetAttribLocation("aColor");
GL.EnableVertexAttribArray(colorLocation);
GL.VertexAttribPointer(colorLocation,4,VertexAttribPointerType.Float,false,7*sizeof(float),3*sizeof(float));

// Paso 16. Completamos UpdateFrame. Vamos cambiar la matriz del mundo con una rotaci'on

Matrix4.CreateFromAxisAngle(_Axis,_RotAngle,out _Model); 
RotAngle+=_RotSpeed*(float)e.Time;
if(_RotAngle>=MathHelper.TwoPi)
      _RotAngle=0;

// Paso 17. Hacemos clear al buffer de color y al buffer de profundidad
 GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit);
 
// Paso18. Hacemos bind del VAO.
GL.BindVertexArray(_vertexArray);

// Paso19. Actualizamos los uniforms. Esto es una transferencia entre la CPU y la GPU. Son las matrices
// de las transformaciones geom'etricas

_shader.SetMatrix4("model",_Model);
_shader.SetMatrix4("view",_camera.GetViewMatrix());
_shader.SetMatrix4("projection",_camera.GetProjectionMatrix());

// Paso 20. Lanzamos la orden Draw
GL.DrawElements(PrimitiveType.Triangles,36,DrawElementsType.UnsignedInt,indexData);

// Paso 21. Hacemos el swap del doble buffer.
SwapBuffers();

// Paso 22. Completamos OnUnload liberando los recursos. Primero los de Window y luego llamamos al
// Unload de la clase base
protected override void OnUnload()
 {
        GL.BindBuffer(BufferTarget.ArrayBuffer,0);
        GL.BindBuffer(BufferTarget.ElementArrayBuffer,0);
        GL.BindVertexArray(0);
        base.OnUnload();
 }

